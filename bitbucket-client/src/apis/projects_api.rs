/*
 * Bitbucket API
 *
 * Code against the Bitbucket API to automate simple tasks, embed Bitbucket data into your own site, build mobile or desktop apps, or even add custom UI add-ons into Bitbucket itself using the Connect framework.
 *
 * The version of the OpenAPI document: 2.0
 * Contact: support@bitbucket.org
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
use serde::{Deserialize, Serialize, de::Error as _};
use crate::{apis::ResponseContent, models};
use super::{Error, configuration, ContentType};


/// struct for typed errors of method [`workspaces_workspace_projects_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum WorkspacesWorkspaceProjectsPostError {
    Status403(models::Error),
    Status404(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`workspaces_workspace_projects_project_key_default_reviewers_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum WorkspacesWorkspaceProjectsProjectKeyDefaultReviewersGetError {
    Status403(models::Error),
    Status404(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`workspaces_workspace_projects_project_key_default_reviewers_selected_user_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum WorkspacesWorkspaceProjectsProjectKeyDefaultReviewersSelectedUserDeleteError {
    Status400(models::Error),
    Status403(models::Error),
    Status404(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`workspaces_workspace_projects_project_key_default_reviewers_selected_user_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum WorkspacesWorkspaceProjectsProjectKeyDefaultReviewersSelectedUserGetError {
    Status400(models::Error),
    Status403(models::Error),
    Status404(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`workspaces_workspace_projects_project_key_default_reviewers_selected_user_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum WorkspacesWorkspaceProjectsProjectKeyDefaultReviewersSelectedUserPutError {
    Status400(models::Error),
    Status403(models::Error),
    Status404(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`workspaces_workspace_projects_project_key_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum WorkspacesWorkspaceProjectsProjectKeyDeleteError {
    Status403(models::Error),
    Status404(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`workspaces_workspace_projects_project_key_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum WorkspacesWorkspaceProjectsProjectKeyGetError {
    Status401(models::Error),
    Status403(models::Error),
    Status404(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`workspaces_workspace_projects_project_key_permissions_config_groups_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum WorkspacesWorkspaceProjectsProjectKeyPermissionsConfigGroupsGetError {
    Status401(models::Error),
    Status403(models::Error),
    Status404(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`workspaces_workspace_projects_project_key_permissions_config_groups_group_slug_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum WorkspacesWorkspaceProjectsProjectKeyPermissionsConfigGroupsGroupSlugDeleteError {
    Status401(models::Error),
    Status403(models::Error),
    Status404(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`workspaces_workspace_projects_project_key_permissions_config_groups_group_slug_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum WorkspacesWorkspaceProjectsProjectKeyPermissionsConfigGroupsGroupSlugGetError {
    Status401(models::Error),
    Status403(models::Error),
    Status404(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`workspaces_workspace_projects_project_key_permissions_config_groups_group_slug_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum WorkspacesWorkspaceProjectsProjectKeyPermissionsConfigGroupsGroupSlugPutError {
    Status400(models::Error),
    Status401(models::Error),
    Status402(models::Error),
    Status403(models::Error),
    Status404(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`workspaces_workspace_projects_project_key_permissions_config_users_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum WorkspacesWorkspaceProjectsProjectKeyPermissionsConfigUsersGetError {
    Status401(models::Error),
    Status403(models::Error),
    Status404(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`workspaces_workspace_projects_project_key_permissions_config_users_selected_user_id_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum WorkspacesWorkspaceProjectsProjectKeyPermissionsConfigUsersSelectedUserIdDeleteError {
    Status401(models::Error),
    Status403(models::Error),
    Status404(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`workspaces_workspace_projects_project_key_permissions_config_users_selected_user_id_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum WorkspacesWorkspaceProjectsProjectKeyPermissionsConfigUsersSelectedUserIdGetError {
    Status401(models::Error),
    Status403(models::Error),
    Status404(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`workspaces_workspace_projects_project_key_permissions_config_users_selected_user_id_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum WorkspacesWorkspaceProjectsProjectKeyPermissionsConfigUsersSelectedUserIdPutError {
    Status400(models::Error),
    Status401(models::Error),
    Status402(models::Error),
    Status403(models::Error),
    Status404(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`workspaces_workspace_projects_project_key_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum WorkspacesWorkspaceProjectsProjectKeyPutError {
    Status403(models::Error),
    Status404(models::Error),
    UnknownValue(serde_json::Value),
}


/// Creates a new project.  Note that the avatar has to be embedded as either a data-url or a URL to an external image as shown in the examples below:  ``` $ body=$(cat << EOF {     \"name\": \"Mars Project\",     \"key\": \"MARS\",     \"description\": \"Software for colonizing mars.\",     \"links\": {         \"avatar\": {             \"href\": \"data:image/gif;base64,R0lGODlhEAAQAMQAAORHHOVSKudfOulrSOp3WOyDZu6QdvCchPGolfO0o/...\"         }     },     \"is_private\": false } EOF ) $ curl -H \"Content-Type: application/json\" \\        -X POST \\        -d \"$body\" \\        https://api.bitbucket.org/2.0/workspaces/teams-in-space/projects/ | jq . {   // Serialized project document } ```  or even:  ``` $ body=$(cat << EOF {     \"name\": \"Mars Project\",     \"key\": \"MARS\",     \"description\": \"Software for colonizing mars.\",     \"links\": {         \"avatar\": {             \"href\": \"http://i.imgur.com/72tRx4w.gif\"         }     },     \"is_private\": false } EOF ) $ curl -H \"Content-Type: application/json\" \\        -X POST \\        -d \"$body\" \\        https://api.bitbucket.org/2.0/workspaces/teams-in-space/projects/ | jq . {   // Serialized project document } ```
pub async fn workspaces_workspace_projects_post(configuration: &configuration::Configuration, workspace: &str, _body: models::Project) -> Result<models::Project, Error<WorkspacesWorkspaceProjectsPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_workspace = workspace;
    let p_body__body = _body;

    let uri_str = format!("{}/workspaces/{workspace}/projects", configuration.base_path, workspace=crate::apis::urlencode(p_path_workspace));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };
    req_builder = req_builder.json(&p_body__body);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_path_to_error::deserialize(&mut serde_json::Deserializer::from_str(&content)).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Project`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Project`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<WorkspacesWorkspaceProjectsPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Return a list of all default reviewers for a project. This is a list of users that will be added as default reviewers to pull requests for any repository within the project.
pub async fn workspaces_workspace_projects_project_key_default_reviewers_get(configuration: &configuration::Configuration, project_key: &str, workspace: &str) -> Result<models::PaginatedDefaultReviewerAndType, Error<WorkspacesWorkspaceProjectsProjectKeyDefaultReviewersGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_project_key = project_key;
    let p_path_workspace = workspace;

    let uri_str = format!("{}/workspaces/{workspace}/projects/{project_key}/default-reviewers", configuration.base_path, project_key=crate::apis::urlencode(p_path_project_key), workspace=crate::apis::urlencode(p_path_workspace));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_path_to_error::deserialize(&mut serde_json::Deserializer::from_str(&content)).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PaginatedDefaultReviewerAndType`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PaginatedDefaultReviewerAndType`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<WorkspacesWorkspaceProjectsProjectKeyDefaultReviewersGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Removes a default reviewer from the project.  Example: ``` $ curl https://api.bitbucket.org/2.0/.../default-reviewers/%7Bf0e0e8e9-66c1-4b85-a784-44a9eb9ef1a6%7D  HTTP/1.1 204 ```
pub async fn workspaces_workspace_projects_project_key_default_reviewers_selected_user_delete(configuration: &configuration::Configuration, project_key: &str, selected_user: &str, workspace: &str) -> Result<(), Error<WorkspacesWorkspaceProjectsProjectKeyDefaultReviewersSelectedUserDeleteError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_project_key = project_key;
    let p_path_selected_user = selected_user;
    let p_path_workspace = workspace;

    let uri_str = format!("{}/workspaces/{workspace}/projects/{project_key}/default-reviewers/{selected_user}", configuration.base_path, project_key=crate::apis::urlencode(p_path_project_key), selected_user=crate::apis::urlencode(p_path_selected_user), workspace=crate::apis::urlencode(p_path_workspace));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<WorkspacesWorkspaceProjectsProjectKeyDefaultReviewersSelectedUserDeleteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Returns the specified default reviewer.
pub async fn workspaces_workspace_projects_project_key_default_reviewers_selected_user_get(configuration: &configuration::Configuration, project_key: &str, selected_user: &str, workspace: &str) -> Result<models::User, Error<WorkspacesWorkspaceProjectsProjectKeyDefaultReviewersSelectedUserGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_project_key = project_key;
    let p_path_selected_user = selected_user;
    let p_path_workspace = workspace;

    let uri_str = format!("{}/workspaces/{workspace}/projects/{project_key}/default-reviewers/{selected_user}", configuration.base_path, project_key=crate::apis::urlencode(p_path_project_key), selected_user=crate::apis::urlencode(p_path_selected_user), workspace=crate::apis::urlencode(p_path_workspace));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_path_to_error::deserialize(&mut serde_json::Deserializer::from_str(&content)).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::User`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::User`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<WorkspacesWorkspaceProjectsProjectKeyDefaultReviewersSelectedUserGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Adds the specified user to the project's list of default reviewers. The method is idempotent. Accepts an optional body containing the `uuid` of the user to be added.
pub async fn workspaces_workspace_projects_project_key_default_reviewers_selected_user_put(configuration: &configuration::Configuration, project_key: &str, selected_user: &str, workspace: &str) -> Result<models::User, Error<WorkspacesWorkspaceProjectsProjectKeyDefaultReviewersSelectedUserPutError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_project_key = project_key;
    let p_path_selected_user = selected_user;
    let p_path_workspace = workspace;

    let uri_str = format!("{}/workspaces/{workspace}/projects/{project_key}/default-reviewers/{selected_user}", configuration.base_path, project_key=crate::apis::urlencode(p_path_project_key), selected_user=crate::apis::urlencode(p_path_selected_user), workspace=crate::apis::urlencode(p_path_workspace));
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_path_to_error::deserialize(&mut serde_json::Deserializer::from_str(&content)).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::User`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::User`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<WorkspacesWorkspaceProjectsProjectKeyDefaultReviewersSelectedUserPutError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Deletes this project. This is an irreversible operation.  You cannot delete a project that still contains repositories. To delete the project, [delete](/cloud/bitbucket/rest/api-group-repositories/#api-repositories-workspace-repo-slug-delete) or transfer the repositories first.  Example: ``` $ curl -X DELETE https://api.bitbucket.org/2.0/workspaces/bbworkspace1/projects/PROJ ```
pub async fn workspaces_workspace_projects_project_key_delete(configuration: &configuration::Configuration, project_key: &str, workspace: &str) -> Result<(), Error<WorkspacesWorkspaceProjectsProjectKeyDeleteError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_project_key = project_key;
    let p_path_workspace = workspace;

    let uri_str = format!("{}/workspaces/{workspace}/projects/{project_key}", configuration.base_path, project_key=crate::apis::urlencode(p_path_project_key), workspace=crate::apis::urlencode(p_path_workspace));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<WorkspacesWorkspaceProjectsProjectKeyDeleteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Returns the requested project.
pub async fn workspaces_workspace_projects_project_key_get(configuration: &configuration::Configuration, project_key: &str, workspace: &str) -> Result<models::Project, Error<WorkspacesWorkspaceProjectsProjectKeyGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_project_key = project_key;
    let p_path_workspace = workspace;

    let uri_str = format!("{}/workspaces/{workspace}/projects/{project_key}", configuration.base_path, project_key=crate::apis::urlencode(p_path_project_key), workspace=crate::apis::urlencode(p_path_workspace));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_path_to_error::deserialize(&mut serde_json::Deserializer::from_str(&content)).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Project`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Project`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<WorkspacesWorkspaceProjectsProjectKeyGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Returns a paginated list of explicit group permissions for the given project. This endpoint does not support BBQL features.
pub async fn workspaces_workspace_projects_project_key_permissions_config_groups_get(configuration: &configuration::Configuration, project_key: &str, workspace: &str) -> Result<models::PaginatedProjectGroupPermissions, Error<WorkspacesWorkspaceProjectsProjectKeyPermissionsConfigGroupsGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_project_key = project_key;
    let p_path_workspace = workspace;

    let uri_str = format!("{}/workspaces/{workspace}/projects/{project_key}/permissions-config/groups", configuration.base_path, project_key=crate::apis::urlencode(p_path_project_key), workspace=crate::apis::urlencode(p_path_workspace));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_path_to_error::deserialize(&mut serde_json::Deserializer::from_str(&content)).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PaginatedProjectGroupPermissions`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PaginatedProjectGroupPermissions`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<WorkspacesWorkspaceProjectsProjectKeyPermissionsConfigGroupsGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Deletes the project group permission between the requested project and group, if one exists.  Only users with admin permission for the project may access this resource.
pub async fn workspaces_workspace_projects_project_key_permissions_config_groups_group_slug_delete(configuration: &configuration::Configuration, group_slug: &str, project_key: &str, workspace: &str) -> Result<(), Error<WorkspacesWorkspaceProjectsProjectKeyPermissionsConfigGroupsGroupSlugDeleteError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_group_slug = group_slug;
    let p_path_project_key = project_key;
    let p_path_workspace = workspace;

    let uri_str = format!("{}/workspaces/{workspace}/projects/{project_key}/permissions-config/groups/{group_slug}", configuration.base_path, group_slug=crate::apis::urlencode(p_path_group_slug), project_key=crate::apis::urlencode(p_path_project_key), workspace=crate::apis::urlencode(p_path_workspace));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<WorkspacesWorkspaceProjectsProjectKeyPermissionsConfigGroupsGroupSlugDeleteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Returns the group permission for a given group and project.  Only users with admin permission for the project may access this resource.  Permissions can be:  * `admin` * `create-repo` * `write` * `read` * `none`
pub async fn workspaces_workspace_projects_project_key_permissions_config_groups_group_slug_get(configuration: &configuration::Configuration, group_slug: &str, project_key: &str, workspace: &str) -> Result<models::ProjectGroupPermission, Error<WorkspacesWorkspaceProjectsProjectKeyPermissionsConfigGroupsGroupSlugGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_group_slug = group_slug;
    let p_path_project_key = project_key;
    let p_path_workspace = workspace;

    let uri_str = format!("{}/workspaces/{workspace}/projects/{project_key}/permissions-config/groups/{group_slug}", configuration.base_path, group_slug=crate::apis::urlencode(p_path_group_slug), project_key=crate::apis::urlencode(p_path_project_key), workspace=crate::apis::urlencode(p_path_workspace));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_path_to_error::deserialize(&mut serde_json::Deserializer::from_str(&content)).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ProjectGroupPermission`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ProjectGroupPermission`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<WorkspacesWorkspaceProjectsProjectKeyPermissionsConfigGroupsGroupSlugGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Updates the group permission, or grants a new permission if one does not already exist.  Only users with admin permission for the project may access this resource.  Due to security concerns, the JWT and OAuth authentication methods are unsupported. This is to ensure integrations and add-ons are not allowed to change permissions.  Permissions can be:  * `admin` * `create-repo` * `write` * `read`
pub async fn workspaces_workspace_projects_project_key_permissions_config_groups_group_slug_put(configuration: &configuration::Configuration, group_slug: &str, project_key: &str, workspace: &str, _body: models::BitbucketAppsPermissionsSerializersProjectPermissionUpdateSchema) -> Result<models::ProjectGroupPermission, Error<WorkspacesWorkspaceProjectsProjectKeyPermissionsConfigGroupsGroupSlugPutError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_group_slug = group_slug;
    let p_path_project_key = project_key;
    let p_path_workspace = workspace;
    let p_body__body = _body;

    let uri_str = format!("{}/workspaces/{workspace}/projects/{project_key}/permissions-config/groups/{group_slug}", configuration.base_path, group_slug=crate::apis::urlencode(p_path_group_slug), project_key=crate::apis::urlencode(p_path_project_key), workspace=crate::apis::urlencode(p_path_workspace));
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };
    req_builder = req_builder.json(&p_body__body);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_path_to_error::deserialize(&mut serde_json::Deserializer::from_str(&content)).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ProjectGroupPermission`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ProjectGroupPermission`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<WorkspacesWorkspaceProjectsProjectKeyPermissionsConfigGroupsGroupSlugPutError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Returns a paginated list of explicit user permissions for the given project. This endpoint does not support BBQL features.
pub async fn workspaces_workspace_projects_project_key_permissions_config_users_get(configuration: &configuration::Configuration, project_key: &str, workspace: &str) -> Result<models::PaginatedProjectUserPermissions, Error<WorkspacesWorkspaceProjectsProjectKeyPermissionsConfigUsersGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_project_key = project_key;
    let p_path_workspace = workspace;

    let uri_str = format!("{}/workspaces/{workspace}/projects/{project_key}/permissions-config/users", configuration.base_path, project_key=crate::apis::urlencode(p_path_project_key), workspace=crate::apis::urlencode(p_path_workspace));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_path_to_error::deserialize(&mut serde_json::Deserializer::from_str(&content)).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PaginatedProjectUserPermissions`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PaginatedProjectUserPermissions`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<WorkspacesWorkspaceProjectsProjectKeyPermissionsConfigUsersGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Deletes the project user permission between the requested project and user, if one exists.  Only users with admin permission for the project may access this resource.  Due to security concerns, the JWT and OAuth authentication methods are unsupported. This is to ensure integrations and add-ons are not allowed to change permissions.
pub async fn workspaces_workspace_projects_project_key_permissions_config_users_selected_user_id_delete(configuration: &configuration::Configuration, project_key: &str, selected_user_id: &str, workspace: &str) -> Result<(), Error<WorkspacesWorkspaceProjectsProjectKeyPermissionsConfigUsersSelectedUserIdDeleteError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_project_key = project_key;
    let p_path_selected_user_id = selected_user_id;
    let p_path_workspace = workspace;

    let uri_str = format!("{}/workspaces/{workspace}/projects/{project_key}/permissions-config/users/{selected_user_id}", configuration.base_path, project_key=crate::apis::urlencode(p_path_project_key), selected_user_id=crate::apis::urlencode(p_path_selected_user_id), workspace=crate::apis::urlencode(p_path_workspace));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<WorkspacesWorkspaceProjectsProjectKeyPermissionsConfigUsersSelectedUserIdDeleteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Returns the explicit user permission for a given user and project.  Only users with admin permission for the project may access this resource.  Permissions can be:  * `admin` * `create-repo` * `write` * `read` * `none`
pub async fn workspaces_workspace_projects_project_key_permissions_config_users_selected_user_id_get(configuration: &configuration::Configuration, project_key: &str, selected_user_id: &str, workspace: &str) -> Result<models::ProjectUserPermission, Error<WorkspacesWorkspaceProjectsProjectKeyPermissionsConfigUsersSelectedUserIdGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_project_key = project_key;
    let p_path_selected_user_id = selected_user_id;
    let p_path_workspace = workspace;

    let uri_str = format!("{}/workspaces/{workspace}/projects/{project_key}/permissions-config/users/{selected_user_id}", configuration.base_path, project_key=crate::apis::urlencode(p_path_project_key), selected_user_id=crate::apis::urlencode(p_path_selected_user_id), workspace=crate::apis::urlencode(p_path_workspace));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_path_to_error::deserialize(&mut serde_json::Deserializer::from_str(&content)).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ProjectUserPermission`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ProjectUserPermission`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<WorkspacesWorkspaceProjectsProjectKeyPermissionsConfigUsersSelectedUserIdGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Updates the explicit user permission for a given user and project. The selected user must be a member of the workspace, and cannot be the workspace owner.  Only users with admin permission for the project may access this resource.  Due to security concerns, the JWT and OAuth authentication methods are unsupported. This is to ensure integrations and add-ons are not allowed to change permissions.  Permissions can be:  * `admin` * `create-repo` * `write` * `read`
pub async fn workspaces_workspace_projects_project_key_permissions_config_users_selected_user_id_put(configuration: &configuration::Configuration, project_key: &str, selected_user_id: &str, workspace: &str, _body: models::BitbucketAppsPermissionsSerializersProjectPermissionUpdateSchema) -> Result<models::ProjectUserPermission, Error<WorkspacesWorkspaceProjectsProjectKeyPermissionsConfigUsersSelectedUserIdPutError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_project_key = project_key;
    let p_path_selected_user_id = selected_user_id;
    let p_path_workspace = workspace;
    let p_body__body = _body;

    let uri_str = format!("{}/workspaces/{workspace}/projects/{project_key}/permissions-config/users/{selected_user_id}", configuration.base_path, project_key=crate::apis::urlencode(p_path_project_key), selected_user_id=crate::apis::urlencode(p_path_selected_user_id), workspace=crate::apis::urlencode(p_path_workspace));
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };
    req_builder = req_builder.json(&p_body__body);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_path_to_error::deserialize(&mut serde_json::Deserializer::from_str(&content)).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ProjectUserPermission`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ProjectUserPermission`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<WorkspacesWorkspaceProjectsProjectKeyPermissionsConfigUsersSelectedUserIdPutError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Since this endpoint can be used to both update and to create a project, the request body depends on the intent.  #### Creation  See the POST documentation for the project collection for an example of the request body.  Note: The `key` should not be specified in the body of request (since it is already present in the URL). The `name` is required, everything else is optional.  #### Update  See the POST documentation for the project collection for an example of the request body.  Note: The key is not required in the body (since it is already in the URL). The key may be specified in the body, if the intent is to change the key itself. In such a scenario, the location of the project is changed and is returned in the `Location` header of the response.
pub async fn workspaces_workspace_projects_project_key_put(configuration: &configuration::Configuration, project_key: &str, workspace: &str, _body: models::Project) -> Result<models::Project, Error<WorkspacesWorkspaceProjectsProjectKeyPutError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_project_key = project_key;
    let p_path_workspace = workspace;
    let p_body__body = _body;

    let uri_str = format!("{}/workspaces/{workspace}/projects/{project_key}", configuration.base_path, project_key=crate::apis::urlencode(p_path_project_key), workspace=crate::apis::urlencode(p_path_workspace));
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };
    req_builder = req_builder.json(&p_body__body);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_path_to_error::deserialize(&mut serde_json::Deserializer::from_str(&content)).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Project`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Project`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<WorkspacesWorkspaceProjectsProjectKeyPutError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

