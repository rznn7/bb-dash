/*
 * Bitbucket API
 *
 * Code against the Bitbucket API to automate simple tasks, embed Bitbucket data into your own site, build mobile or desktop apps, or even add custom UI add-ons into Bitbucket itself using the Connect framework.
 *
 * The version of the OpenAPI document: 2.0
 * Contact: support@bitbucket.org
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
use serde::{Deserialize, Serialize, de::Error as _};
use crate::{apis::ResponseContent, models};
use super::{Error, configuration, ContentType};


/// struct for typed errors of method [`repositories_workspace_repo_slug_components_component_id_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RepositoriesWorkspaceRepoSlugComponentsComponentIdGetError {
    Status404(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`repositories_workspace_repo_slug_components_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RepositoriesWorkspaceRepoSlugComponentsGetError {
    Status404(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`repositories_workspace_repo_slug_issues_export_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RepositoriesWorkspaceRepoSlugIssuesExportPostError {
    Status401(models::Error),
    Status403(models::Error),
    Status404(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`repositories_workspace_repo_slug_issues_export_repo_name_issues_task_id_zip_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RepositoriesWorkspaceRepoSlugIssuesExportRepoNameIssuesTaskIdZipGetError {
    Status401(models::Error),
    Status403(models::Error),
    Status404(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`repositories_workspace_repo_slug_issues_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RepositoriesWorkspaceRepoSlugIssuesGetError {
    Status404(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`repositories_workspace_repo_slug_issues_import_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RepositoriesWorkspaceRepoSlugIssuesImportGetError {
    Status401(models::Error),
    Status403(models::Error),
    Status404(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`repositories_workspace_repo_slug_issues_import_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RepositoriesWorkspaceRepoSlugIssuesImportPostError {
    Status401(models::Error),
    Status403(models::Error),
    Status404(models::Error),
    Status409(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`repositories_workspace_repo_slug_issues_issue_id_attachments_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RepositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsGetError {
    Status401(),
    Status404(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`repositories_workspace_repo_slug_issues_issue_id_attachments_path_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RepositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsPathDeleteError {
    Status401(),
    Status404(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`repositories_workspace_repo_slug_issues_issue_id_attachments_path_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RepositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsPathGetError {
    Status401(),
    Status404(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`repositories_workspace_repo_slug_issues_issue_id_attachments_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RepositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsPostError {
    Status400(),
    Status401(),
    Status404(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`repositories_workspace_repo_slug_issues_issue_id_changes_change_id_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RepositoriesWorkspaceRepoSlugIssuesIssueIdChangesChangeIdGetError {
    Status404(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`repositories_workspace_repo_slug_issues_issue_id_changes_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RepositoriesWorkspaceRepoSlugIssuesIssueIdChangesGetError {
    Status404(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`repositories_workspace_repo_slug_issues_issue_id_changes_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RepositoriesWorkspaceRepoSlugIssuesIssueIdChangesPostError {
    Status401(models::Error),
    Status403(models::Error),
    Status404(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`repositories_workspace_repo_slug_issues_issue_id_comments_comment_id_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RepositoriesWorkspaceRepoSlugIssuesIssueIdCommentsCommentIdDeleteError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`repositories_workspace_repo_slug_issues_issue_id_comments_comment_id_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RepositoriesWorkspaceRepoSlugIssuesIssueIdCommentsCommentIdGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`repositories_workspace_repo_slug_issues_issue_id_comments_comment_id_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RepositoriesWorkspaceRepoSlugIssuesIssueIdCommentsCommentIdPutError {
    Status400(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`repositories_workspace_repo_slug_issues_issue_id_comments_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RepositoriesWorkspaceRepoSlugIssuesIssueIdCommentsGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`repositories_workspace_repo_slug_issues_issue_id_comments_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RepositoriesWorkspaceRepoSlugIssuesIssueIdCommentsPostError {
    Status400(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`repositories_workspace_repo_slug_issues_issue_id_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RepositoriesWorkspaceRepoSlugIssuesIssueIdDeleteError {
    Status403(models::Error),
    Status404(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`repositories_workspace_repo_slug_issues_issue_id_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RepositoriesWorkspaceRepoSlugIssuesIssueIdGetError {
    Status403(models::Error),
    Status404(models::Error),
    Status410(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`repositories_workspace_repo_slug_issues_issue_id_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RepositoriesWorkspaceRepoSlugIssuesIssueIdPutError {
    Status403(models::Error),
    Status404(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`repositories_workspace_repo_slug_issues_issue_id_vote_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RepositoriesWorkspaceRepoSlugIssuesIssueIdVoteDeleteError {
    DefaultResponse(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`repositories_workspace_repo_slug_issues_issue_id_vote_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RepositoriesWorkspaceRepoSlugIssuesIssueIdVoteGetError {
    Status401(models::Error),
    Status404(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`repositories_workspace_repo_slug_issues_issue_id_vote_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RepositoriesWorkspaceRepoSlugIssuesIssueIdVotePutError {
    Status401(models::Error),
    Status404(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`repositories_workspace_repo_slug_issues_issue_id_watch_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RepositoriesWorkspaceRepoSlugIssuesIssueIdWatchDeleteError {
    Status401(models::Error),
    Status404(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`repositories_workspace_repo_slug_issues_issue_id_watch_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RepositoriesWorkspaceRepoSlugIssuesIssueIdWatchGetError {
    Status401(models::Error),
    Status404(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`repositories_workspace_repo_slug_issues_issue_id_watch_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RepositoriesWorkspaceRepoSlugIssuesIssueIdWatchPutError {
    Status401(models::Error),
    Status404(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`repositories_workspace_repo_slug_issues_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RepositoriesWorkspaceRepoSlugIssuesPostError {
    Status401(models::Error),
    Status403(models::Error),
    Status404(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`repositories_workspace_repo_slug_milestones_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RepositoriesWorkspaceRepoSlugMilestonesGetError {
    Status404(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`repositories_workspace_repo_slug_milestones_milestone_id_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RepositoriesWorkspaceRepoSlugMilestonesMilestoneIdGetError {
    Status404(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`repositories_workspace_repo_slug_versions_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RepositoriesWorkspaceRepoSlugVersionsGetError {
    Status404(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`repositories_workspace_repo_slug_versions_version_id_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RepositoriesWorkspaceRepoSlugVersionsVersionIdGetError {
    Status404(models::Error),
    UnknownValue(serde_json::Value),
}


/// Returns the specified issue tracker component object.
pub async fn repositories_workspace_repo_slug_components_component_id_get(configuration: &configuration::Configuration, component_id: i32, repo_slug: &str, workspace: &str) -> Result<models::Component, Error<RepositoriesWorkspaceRepoSlugComponentsComponentIdGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_component_id = component_id;
    let p_path_repo_slug = repo_slug;
    let p_path_workspace = workspace;

    let uri_str = format!("{}/repositories/{workspace}/{repo_slug}/components/{component_id}", configuration.base_path, component_id=p_path_component_id, repo_slug=crate::apis::urlencode(p_path_repo_slug), workspace=crate::apis::urlencode(p_path_workspace));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_path_to_error::deserialize(&mut serde_json::Deserializer::from_str(&content)).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Component`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Component`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<RepositoriesWorkspaceRepoSlugComponentsComponentIdGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Returns the components that have been defined in the issue tracker.  This resource is only available on repositories that have the issue tracker enabled.
pub async fn repositories_workspace_repo_slug_components_get(configuration: &configuration::Configuration, repo_slug: &str, workspace: &str) -> Result<models::PaginatedComponents, Error<RepositoriesWorkspaceRepoSlugComponentsGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_repo_slug = repo_slug;
    let p_path_workspace = workspace;

    let uri_str = format!("{}/repositories/{workspace}/{repo_slug}/components", configuration.base_path, repo_slug=crate::apis::urlencode(p_path_repo_slug), workspace=crate::apis::urlencode(p_path_workspace));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_path_to_error::deserialize(&mut serde_json::Deserializer::from_str(&content)).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PaginatedComponents`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PaginatedComponents`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<RepositoriesWorkspaceRepoSlugComponentsGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// A POST request to this endpoint initiates a new background celery task that archives the repo's issues.  When the job has been accepted, it will return a 202 (Accepted) along with a unique url to this job in the 'Location' response header. This url is the endpoint for where the user can obtain their zip files.\"
pub async fn repositories_workspace_repo_slug_issues_export_post(configuration: &configuration::Configuration, repo_slug: &str, workspace: &str, _body: Option<models::ExportOptions>) -> Result<(), Error<RepositoriesWorkspaceRepoSlugIssuesExportPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_repo_slug = repo_slug;
    let p_path_workspace = workspace;
    let p_body__body = _body;

    let uri_str = format!("{}/repositories/{workspace}/{repo_slug}/issues/export", configuration.base_path, repo_slug=crate::apis::urlencode(p_path_repo_slug), workspace=crate::apis::urlencode(p_path_workspace));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };
    req_builder = req_builder.json(&p_body__body);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<RepositoriesWorkspaceRepoSlugIssuesExportPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// This endpoint is used to poll for the progress of an issue export job and return the zip file after the job is complete. As long as the job is running, this will return a 202 response with in the response body a description of the current status.  After the job has been scheduled, but before it starts executing, the endpoint returns a 202 response with status `ACCEPTED`.  Once it starts running, it is a 202 response with status `STARTED` and progress filled.  After it is finished, it becomes a 200 response with status `SUCCESS` or `FAILURE`.
pub async fn repositories_workspace_repo_slug_issues_export_repo_name_issues_task_id_zip_get(configuration: &configuration::Configuration, repo_name: &str, repo_slug: &str, task_id: &str, workspace: &str) -> Result<models::IssueJobStatus, Error<RepositoriesWorkspaceRepoSlugIssuesExportRepoNameIssuesTaskIdZipGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_repo_name = repo_name;
    let p_path_repo_slug = repo_slug;
    let p_path_task_id = task_id;
    let p_path_workspace = workspace;

    let uri_str = format!("{}/repositories/{workspace}/{repo_slug}/issues/export/{repo_name}-issues-{task_id}.zip", configuration.base_path, repo_name=crate::apis::urlencode(p_path_repo_name), repo_slug=crate::apis::urlencode(p_path_repo_slug), task_id=crate::apis::urlencode(p_path_task_id), workspace=crate::apis::urlencode(p_path_workspace));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_path_to_error::deserialize(&mut serde_json::Deserializer::from_str(&content)).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::IssueJobStatus`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::IssueJobStatus`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<RepositoriesWorkspaceRepoSlugIssuesExportRepoNameIssuesTaskIdZipGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Returns the issues in the issue tracker.
pub async fn repositories_workspace_repo_slug_issues_get(configuration: &configuration::Configuration, repo_slug: &str, workspace: &str) -> Result<models::PaginatedIssues, Error<RepositoriesWorkspaceRepoSlugIssuesGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_repo_slug = repo_slug;
    let p_path_workspace = workspace;

    let uri_str = format!("{}/repositories/{workspace}/{repo_slug}/issues", configuration.base_path, repo_slug=crate::apis::urlencode(p_path_repo_slug), workspace=crate::apis::urlencode(p_path_workspace));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_path_to_error::deserialize(&mut serde_json::Deserializer::from_str(&content)).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PaginatedIssues`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PaginatedIssues`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<RepositoriesWorkspaceRepoSlugIssuesGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// When using GET, this endpoint reports the status of the current import task.  After the job has been scheduled, but before it starts executing, the endpoint returns a 202 response with status `ACCEPTED`.  Once it starts running, it is a 202 response with status `STARTED` and progress filled.  After it is finished, it becomes a 200 response with status `SUCCESS` or `FAILURE`.
pub async fn repositories_workspace_repo_slug_issues_import_get(configuration: &configuration::Configuration, repo_slug: &str, workspace: &str) -> Result<models::IssueJobStatus, Error<RepositoriesWorkspaceRepoSlugIssuesImportGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_repo_slug = repo_slug;
    let p_path_workspace = workspace;

    let uri_str = format!("{}/repositories/{workspace}/{repo_slug}/issues/import", configuration.base_path, repo_slug=crate::apis::urlencode(p_path_repo_slug), workspace=crate::apis::urlencode(p_path_workspace));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_path_to_error::deserialize(&mut serde_json::Deserializer::from_str(&content)).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::IssueJobStatus`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::IssueJobStatus`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<RepositoriesWorkspaceRepoSlugIssuesImportGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// A POST request to this endpoint will import the zip file given by the archive parameter into the repository. All existing issues will be deleted and replaced by the contents of the imported zip file.  Imports are done through a multipart/form-data POST. There is one valid and required form field, with the name \"archive,\" which needs to be a file field:  ``` $ curl -u <username> -X POST -F archive=@/path/to/file.zip https://api.bitbucket.org/2.0/repositories/<owner_username>/<repo_slug>/issues/import ```
pub async fn repositories_workspace_repo_slug_issues_import_post(configuration: &configuration::Configuration, repo_slug: &str, workspace: &str) -> Result<models::IssueJobStatus, Error<RepositoriesWorkspaceRepoSlugIssuesImportPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_repo_slug = repo_slug;
    let p_path_workspace = workspace;

    let uri_str = format!("{}/repositories/{workspace}/{repo_slug}/issues/import", configuration.base_path, repo_slug=crate::apis::urlencode(p_path_repo_slug), workspace=crate::apis::urlencode(p_path_workspace));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_path_to_error::deserialize(&mut serde_json::Deserializer::from_str(&content)).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::IssueJobStatus`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::IssueJobStatus`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<RepositoriesWorkspaceRepoSlugIssuesImportPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Returns all attachments for this issue.  This returns the files' meta data. This does not return the files' actual contents.  The files are always ordered by their upload date.
pub async fn repositories_workspace_repo_slug_issues_issue_id_attachments_get(configuration: &configuration::Configuration, issue_id: &str, repo_slug: &str, workspace: &str) -> Result<models::PaginatedIssueAttachments, Error<RepositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_issue_id = issue_id;
    let p_path_repo_slug = repo_slug;
    let p_path_workspace = workspace;

    let uri_str = format!("{}/repositories/{workspace}/{repo_slug}/issues/{issue_id}/attachments", configuration.base_path, issue_id=crate::apis::urlencode(p_path_issue_id), repo_slug=crate::apis::urlencode(p_path_repo_slug), workspace=crate::apis::urlencode(p_path_workspace));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_path_to_error::deserialize(&mut serde_json::Deserializer::from_str(&content)).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PaginatedIssueAttachments`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PaginatedIssueAttachments`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<RepositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Deletes an attachment.
pub async fn repositories_workspace_repo_slug_issues_issue_id_attachments_path_delete(configuration: &configuration::Configuration, issue_id: &str, path: &str, repo_slug: &str, workspace: &str) -> Result<(), Error<RepositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsPathDeleteError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_issue_id = issue_id;
    let p_path_path = path;
    let p_path_repo_slug = repo_slug;
    let p_path_workspace = workspace;

    let uri_str = format!("{}/repositories/{workspace}/{repo_slug}/issues/{issue_id}/attachments/{path}", configuration.base_path, issue_id=crate::apis::urlencode(p_path_issue_id), path=crate::apis::urlencode(p_path_path), repo_slug=crate::apis::urlencode(p_path_repo_slug), workspace=crate::apis::urlencode(p_path_workspace));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<RepositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsPathDeleteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Returns the contents of the specified file attachment.  Note that this endpoint does not return a JSON response, but instead returns a redirect pointing to the actual file that in turn will return the raw contents.  The redirect URL contains a one-time token that has a limited lifetime. As a result, the link should not be persisted, stored, or shared.
pub async fn repositories_workspace_repo_slug_issues_issue_id_attachments_path_get(configuration: &configuration::Configuration, issue_id: &str, path: &str, repo_slug: &str, workspace: &str) -> Result<(), Error<RepositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsPathGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_issue_id = issue_id;
    let p_path_path = path;
    let p_path_repo_slug = repo_slug;
    let p_path_workspace = workspace;

    let uri_str = format!("{}/repositories/{workspace}/{repo_slug}/issues/{issue_id}/attachments/{path}", configuration.base_path, issue_id=crate::apis::urlencode(p_path_issue_id), path=crate::apis::urlencode(p_path_path), repo_slug=crate::apis::urlencode(p_path_repo_slug), workspace=crate::apis::urlencode(p_path_workspace));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<RepositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsPathGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Upload new issue attachments.  To upload files, perform a `multipart/form-data` POST containing one or more file fields.  When a file is uploaded with the same name as an existing attachment, then the existing file will be replaced.
pub async fn repositories_workspace_repo_slug_issues_issue_id_attachments_post(configuration: &configuration::Configuration, issue_id: &str, repo_slug: &str, workspace: &str) -> Result<(), Error<RepositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_issue_id = issue_id;
    let p_path_repo_slug = repo_slug;
    let p_path_workspace = workspace;

    let uri_str = format!("{}/repositories/{workspace}/{repo_slug}/issues/{issue_id}/attachments", configuration.base_path, issue_id=crate::apis::urlencode(p_path_issue_id), repo_slug=crate::apis::urlencode(p_path_repo_slug), workspace=crate::apis::urlencode(p_path_workspace));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<RepositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Returns the specified issue change object.  This resource is only available on repositories that have the issue tracker enabled.
pub async fn repositories_workspace_repo_slug_issues_issue_id_changes_change_id_get(configuration: &configuration::Configuration, change_id: &str, issue_id: &str, repo_slug: &str, workspace: &str) -> Result<models::IssueChange, Error<RepositoriesWorkspaceRepoSlugIssuesIssueIdChangesChangeIdGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_change_id = change_id;
    let p_path_issue_id = issue_id;
    let p_path_repo_slug = repo_slug;
    let p_path_workspace = workspace;

    let uri_str = format!("{}/repositories/{workspace}/{repo_slug}/issues/{issue_id}/changes/{change_id}", configuration.base_path, change_id=crate::apis::urlencode(p_path_change_id), issue_id=crate::apis::urlencode(p_path_issue_id), repo_slug=crate::apis::urlencode(p_path_repo_slug), workspace=crate::apis::urlencode(p_path_workspace));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_path_to_error::deserialize(&mut serde_json::Deserializer::from_str(&content)).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::IssueChange`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::IssueChange`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<RepositoriesWorkspaceRepoSlugIssuesIssueIdChangesChangeIdGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Returns the list of all changes that have been made to the specified issue. Changes are returned in chronological order with the oldest change first.  Each time an issue is edited in the UI or through the API, an immutable change record is created under the `/issues/123/changes` endpoint. It also has a comment associated with the change.  Note that this operation is changing significantly, due to privacy changes. See the [announcement](https://developer.atlassian.com/cloud/bitbucket/bitbucket-api-changes-gdpr/#changes-to-the-issue-changes-api) for details.  Changes support [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering) that can be used to search for specific changes. For instance, to see when an issue transitioned to \"resolved\":  ``` $ curl -s https://api.bitbucket.org/2.0/repositories/site/master/issues/1/changes \\    -G --data-urlencode='q=changes.state.new = \"resolved\"' ```  This resource is only available on repositories that have the issue tracker enabled.  N.B.  The `changes.assignee` and `changes.assignee_account_id` fields are not a `user` object. Instead, they contain the raw `username` and `account_id` of the user. This is to protect the integrity of the audit log even after a user account gets deleted.  The `changes.assignee` field is deprecated will disappear in the future. Use `changes.assignee_account_id` instead.
pub async fn repositories_workspace_repo_slug_issues_issue_id_changes_get(configuration: &configuration::Configuration, issue_id: &str, repo_slug: &str, workspace: &str, q: Option<&str>, sort: Option<&str>) -> Result<models::PaginatedLogEntries, Error<RepositoriesWorkspaceRepoSlugIssuesIssueIdChangesGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_issue_id = issue_id;
    let p_path_repo_slug = repo_slug;
    let p_path_workspace = workspace;
    let p_query_q = q;
    let p_query_sort = sort;

    let uri_str = format!("{}/repositories/{workspace}/{repo_slug}/issues/{issue_id}/changes", configuration.base_path, issue_id=crate::apis::urlencode(p_path_issue_id), repo_slug=crate::apis::urlencode(p_path_repo_slug), workspace=crate::apis::urlencode(p_path_workspace));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_q {
        req_builder = req_builder.query(&[("q", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_sort {
        req_builder = req_builder.query(&[("sort", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_path_to_error::deserialize(&mut serde_json::Deserializer::from_str(&content)).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PaginatedLogEntries`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PaginatedLogEntries`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<RepositoriesWorkspaceRepoSlugIssuesIssueIdChangesGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Makes a change to the specified issue.  For example, to change an issue's state and assignee, create a new change object that modifies these fields:  ``` curl https://api.bitbucket.org/2.0/site/master/issues/1234/changes \\   -s -u evzijst -X POST -H \"Content-Type: application/json\" \\   -d '{     \"changes\": {       \"assignee_account_id\": {         \"new\": \"557058:c0b72ad0-1cb5-4018-9cdc-0cde8492c443\"       },       \"state\": {         \"new\": 'resolved\"       }     }     \"message\": {       \"raw\": \"This is now resolved.\"     }   }' ```  The above example also includes a custom comment to go alongside the change. This comment will also be visible on the issue page in the UI.  The fields of the `changes` object are strings, not objects. This allows for immutable change log records, even after user accounts, milestones, or other objects recorded in a change entry, get renamed or deleted.  The `assignee_account_id` field stores the account id. When POSTing a new change and changing the assignee, the client should therefore use the user's account_id in the `changes.assignee_account_id.new` field.  This call requires authentication. Private repositories or private issue trackers require the caller to authenticate with an account that has appropriate authorization.
pub async fn repositories_workspace_repo_slug_issues_issue_id_changes_post(configuration: &configuration::Configuration, issue_id: &str, repo_slug: &str, workspace: &str, _body: models::IssueChange) -> Result<models::IssueChange, Error<RepositoriesWorkspaceRepoSlugIssuesIssueIdChangesPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_issue_id = issue_id;
    let p_path_repo_slug = repo_slug;
    let p_path_workspace = workspace;
    let p_body__body = _body;

    let uri_str = format!("{}/repositories/{workspace}/{repo_slug}/issues/{issue_id}/changes", configuration.base_path, issue_id=crate::apis::urlencode(p_path_issue_id), repo_slug=crate::apis::urlencode(p_path_repo_slug), workspace=crate::apis::urlencode(p_path_workspace));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };
    req_builder = req_builder.json(&p_body__body);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_path_to_error::deserialize(&mut serde_json::Deserializer::from_str(&content)).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::IssueChange`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::IssueChange`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<RepositoriesWorkspaceRepoSlugIssuesIssueIdChangesPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Deletes the specified comment.
pub async fn repositories_workspace_repo_slug_issues_issue_id_comments_comment_id_delete(configuration: &configuration::Configuration, comment_id: i64, issue_id: &str, repo_slug: &str, workspace: &str) -> Result<(), Error<RepositoriesWorkspaceRepoSlugIssuesIssueIdCommentsCommentIdDeleteError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_comment_id = comment_id;
    let p_path_issue_id = issue_id;
    let p_path_repo_slug = repo_slug;
    let p_path_workspace = workspace;

    let uri_str = format!("{}/repositories/{workspace}/{repo_slug}/issues/{issue_id}/comments/{comment_id}", configuration.base_path, comment_id=p_path_comment_id, issue_id=crate::apis::urlencode(p_path_issue_id), repo_slug=crate::apis::urlencode(p_path_repo_slug), workspace=crate::apis::urlencode(p_path_workspace));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<RepositoriesWorkspaceRepoSlugIssuesIssueIdCommentsCommentIdDeleteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Returns the specified issue comment object.
pub async fn repositories_workspace_repo_slug_issues_issue_id_comments_comment_id_get(configuration: &configuration::Configuration, comment_id: i64, issue_id: &str, repo_slug: &str, workspace: &str) -> Result<models::IssueComment, Error<RepositoriesWorkspaceRepoSlugIssuesIssueIdCommentsCommentIdGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_comment_id = comment_id;
    let p_path_issue_id = issue_id;
    let p_path_repo_slug = repo_slug;
    let p_path_workspace = workspace;

    let uri_str = format!("{}/repositories/{workspace}/{repo_slug}/issues/{issue_id}/comments/{comment_id}", configuration.base_path, comment_id=p_path_comment_id, issue_id=crate::apis::urlencode(p_path_issue_id), repo_slug=crate::apis::urlencode(p_path_repo_slug), workspace=crate::apis::urlencode(p_path_workspace));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_path_to_error::deserialize(&mut serde_json::Deserializer::from_str(&content)).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::IssueComment`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::IssueComment`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<RepositoriesWorkspaceRepoSlugIssuesIssueIdCommentsCommentIdGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Updates the content of the specified issue comment. Note that only the `content.raw` field can be modified.  ``` $ curl https://api.bitbucket.org/2.0/repositories/atlassian/prlinks/issues/42/comments/5728901 \\   -X PUT -u evzijst \\   -H 'Content-Type: application/json' \\   -d '{\"content\": {\"raw\": \"Lorem ipsum.\"}' ```
pub async fn repositories_workspace_repo_slug_issues_issue_id_comments_comment_id_put(configuration: &configuration::Configuration, comment_id: i64, issue_id: &str, repo_slug: &str, workspace: &str, _body: models::IssueComment) -> Result<models::IssueComment, Error<RepositoriesWorkspaceRepoSlugIssuesIssueIdCommentsCommentIdPutError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_comment_id = comment_id;
    let p_path_issue_id = issue_id;
    let p_path_repo_slug = repo_slug;
    let p_path_workspace = workspace;
    let p_body__body = _body;

    let uri_str = format!("{}/repositories/{workspace}/{repo_slug}/issues/{issue_id}/comments/{comment_id}", configuration.base_path, comment_id=p_path_comment_id, issue_id=crate::apis::urlencode(p_path_issue_id), repo_slug=crate::apis::urlencode(p_path_repo_slug), workspace=crate::apis::urlencode(p_path_workspace));
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };
    req_builder = req_builder.json(&p_body__body);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_path_to_error::deserialize(&mut serde_json::Deserializer::from_str(&content)).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::IssueComment`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::IssueComment`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<RepositoriesWorkspaceRepoSlugIssuesIssueIdCommentsCommentIdPutError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Returns a paginated list of all comments that were made on the specified issue.  The default sorting is oldest to newest and can be overridden with the `sort` query parameter.  This endpoint also supports filtering and sorting of the results. See [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering) for more details.
pub async fn repositories_workspace_repo_slug_issues_issue_id_comments_get(configuration: &configuration::Configuration, issue_id: &str, repo_slug: &str, workspace: &str, q: Option<&str>) -> Result<models::PaginatedIssueComments, Error<RepositoriesWorkspaceRepoSlugIssuesIssueIdCommentsGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_issue_id = issue_id;
    let p_path_repo_slug = repo_slug;
    let p_path_workspace = workspace;
    let p_query_q = q;

    let uri_str = format!("{}/repositories/{workspace}/{repo_slug}/issues/{issue_id}/comments", configuration.base_path, issue_id=crate::apis::urlencode(p_path_issue_id), repo_slug=crate::apis::urlencode(p_path_repo_slug), workspace=crate::apis::urlencode(p_path_workspace));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_q {
        req_builder = req_builder.query(&[("q", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_path_to_error::deserialize(&mut serde_json::Deserializer::from_str(&content)).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PaginatedIssueComments`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PaginatedIssueComments`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<RepositoriesWorkspaceRepoSlugIssuesIssueIdCommentsGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Creates a new issue comment.  ``` $ curl https://api.bitbucket.org/2.0/repositories/atlassian/prlinks/issues/42/comments/ \\   -X POST -u evzijst \\   -H 'Content-Type: application/json' \\   -d '{\"content\": {\"raw\": \"Lorem ipsum.\"}}' ```
pub async fn repositories_workspace_repo_slug_issues_issue_id_comments_post(configuration: &configuration::Configuration, issue_id: &str, repo_slug: &str, workspace: &str, _body: models::IssueComment) -> Result<(), Error<RepositoriesWorkspaceRepoSlugIssuesIssueIdCommentsPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_issue_id = issue_id;
    let p_path_repo_slug = repo_slug;
    let p_path_workspace = workspace;
    let p_body__body = _body;

    let uri_str = format!("{}/repositories/{workspace}/{repo_slug}/issues/{issue_id}/comments", configuration.base_path, issue_id=crate::apis::urlencode(p_path_issue_id), repo_slug=crate::apis::urlencode(p_path_repo_slug), workspace=crate::apis::urlencode(p_path_workspace));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };
    req_builder = req_builder.json(&p_body__body);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<RepositoriesWorkspaceRepoSlugIssuesIssueIdCommentsPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Deletes the specified issue. This requires write access to the repository.
pub async fn repositories_workspace_repo_slug_issues_issue_id_delete(configuration: &configuration::Configuration, issue_id: &str, repo_slug: &str, workspace: &str) -> Result<(), Error<RepositoriesWorkspaceRepoSlugIssuesIssueIdDeleteError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_issue_id = issue_id;
    let p_path_repo_slug = repo_slug;
    let p_path_workspace = workspace;

    let uri_str = format!("{}/repositories/{workspace}/{repo_slug}/issues/{issue_id}", configuration.base_path, issue_id=crate::apis::urlencode(p_path_issue_id), repo_slug=crate::apis::urlencode(p_path_repo_slug), workspace=crate::apis::urlencode(p_path_workspace));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<RepositoriesWorkspaceRepoSlugIssuesIssueIdDeleteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Returns the specified issue.
pub async fn repositories_workspace_repo_slug_issues_issue_id_get(configuration: &configuration::Configuration, issue_id: &str, repo_slug: &str, workspace: &str) -> Result<models::Issue, Error<RepositoriesWorkspaceRepoSlugIssuesIssueIdGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_issue_id = issue_id;
    let p_path_repo_slug = repo_slug;
    let p_path_workspace = workspace;

    let uri_str = format!("{}/repositories/{workspace}/{repo_slug}/issues/{issue_id}", configuration.base_path, issue_id=crate::apis::urlencode(p_path_issue_id), repo_slug=crate::apis::urlencode(p_path_repo_slug), workspace=crate::apis::urlencode(p_path_workspace));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_path_to_error::deserialize(&mut serde_json::Deserializer::from_str(&content)).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Issue`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Issue`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<RepositoriesWorkspaceRepoSlugIssuesIssueIdGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Modifies the issue.  ``` $ curl https://api.bitbucket.org/2.0/repostories/evzijst/dogslow/issues/123 \\   -u evzijst -s -X PUT -H 'Content-Type: application/json' \\   -d '{   \"title\": \"Updated title\",   \"assignee\": {     \"account_id\": \"5d5355e8c6b9320d9ea5b28d\"   },   \"priority\": \"minor\",   \"version\": {     \"name\": \"1.0\"   },   \"component\": null }' ```  This example changes the `title`, `assignee`, `priority` and the `version`. It also removes the value of the `component` from the issue by setting the field to `null`. Any field not present keeps its existing value.  Each time an issue is edited in the UI or through the API, an immutable change record is created under the `/issues/123/changes` endpoint. It also has a comment associated with the change.
pub async fn repositories_workspace_repo_slug_issues_issue_id_put(configuration: &configuration::Configuration, issue_id: &str, repo_slug: &str, workspace: &str) -> Result<models::Issue, Error<RepositoriesWorkspaceRepoSlugIssuesIssueIdPutError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_issue_id = issue_id;
    let p_path_repo_slug = repo_slug;
    let p_path_workspace = workspace;

    let uri_str = format!("{}/repositories/{workspace}/{repo_slug}/issues/{issue_id}", configuration.base_path, issue_id=crate::apis::urlencode(p_path_issue_id), repo_slug=crate::apis::urlencode(p_path_repo_slug), workspace=crate::apis::urlencode(p_path_workspace));
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_path_to_error::deserialize(&mut serde_json::Deserializer::from_str(&content)).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Issue`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Issue`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<RepositoriesWorkspaceRepoSlugIssuesIssueIdPutError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retract your vote.
pub async fn repositories_workspace_repo_slug_issues_issue_id_vote_delete(configuration: &configuration::Configuration, issue_id: &str, repo_slug: &str, workspace: &str) -> Result<models::Error, Error<RepositoriesWorkspaceRepoSlugIssuesIssueIdVoteDeleteError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_issue_id = issue_id;
    let p_path_repo_slug = repo_slug;
    let p_path_workspace = workspace;

    let uri_str = format!("{}/repositories/{workspace}/{repo_slug}/issues/{issue_id}/vote", configuration.base_path, issue_id=crate::apis::urlencode(p_path_issue_id), repo_slug=crate::apis::urlencode(p_path_repo_slug), workspace=crate::apis::urlencode(p_path_workspace));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_path_to_error::deserialize(&mut serde_json::Deserializer::from_str(&content)).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Error`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Error`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<RepositoriesWorkspaceRepoSlugIssuesIssueIdVoteDeleteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Check whether the authenticated user has voted for this issue. A 204 status code indicates that the user has voted, while a 404 implies they haven't.
pub async fn repositories_workspace_repo_slug_issues_issue_id_vote_get(configuration: &configuration::Configuration, issue_id: &str, repo_slug: &str, workspace: &str) -> Result<models::Error, Error<RepositoriesWorkspaceRepoSlugIssuesIssueIdVoteGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_issue_id = issue_id;
    let p_path_repo_slug = repo_slug;
    let p_path_workspace = workspace;

    let uri_str = format!("{}/repositories/{workspace}/{repo_slug}/issues/{issue_id}/vote", configuration.base_path, issue_id=crate::apis::urlencode(p_path_issue_id), repo_slug=crate::apis::urlencode(p_path_repo_slug), workspace=crate::apis::urlencode(p_path_workspace));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_path_to_error::deserialize(&mut serde_json::Deserializer::from_str(&content)).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Error`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Error`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<RepositoriesWorkspaceRepoSlugIssuesIssueIdVoteGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Vote for this issue.  To cast your vote, do an empty PUT. The 204 status code indicates that the operation was successful.
pub async fn repositories_workspace_repo_slug_issues_issue_id_vote_put(configuration: &configuration::Configuration, issue_id: &str, repo_slug: &str, workspace: &str) -> Result<models::Error, Error<RepositoriesWorkspaceRepoSlugIssuesIssueIdVotePutError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_issue_id = issue_id;
    let p_path_repo_slug = repo_slug;
    let p_path_workspace = workspace;

    let uri_str = format!("{}/repositories/{workspace}/{repo_slug}/issues/{issue_id}/vote", configuration.base_path, issue_id=crate::apis::urlencode(p_path_issue_id), repo_slug=crate::apis::urlencode(p_path_repo_slug), workspace=crate::apis::urlencode(p_path_workspace));
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_path_to_error::deserialize(&mut serde_json::Deserializer::from_str(&content)).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Error`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Error`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<RepositoriesWorkspaceRepoSlugIssuesIssueIdVotePutError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Stop watching this issue.
pub async fn repositories_workspace_repo_slug_issues_issue_id_watch_delete(configuration: &configuration::Configuration, issue_id: &str, repo_slug: &str, workspace: &str) -> Result<models::Error, Error<RepositoriesWorkspaceRepoSlugIssuesIssueIdWatchDeleteError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_issue_id = issue_id;
    let p_path_repo_slug = repo_slug;
    let p_path_workspace = workspace;

    let uri_str = format!("{}/repositories/{workspace}/{repo_slug}/issues/{issue_id}/watch", configuration.base_path, issue_id=crate::apis::urlencode(p_path_issue_id), repo_slug=crate::apis::urlencode(p_path_repo_slug), workspace=crate::apis::urlencode(p_path_workspace));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_path_to_error::deserialize(&mut serde_json::Deserializer::from_str(&content)).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Error`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Error`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<RepositoriesWorkspaceRepoSlugIssuesIssueIdWatchDeleteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Indicated whether or not the authenticated user is watching this issue.
pub async fn repositories_workspace_repo_slug_issues_issue_id_watch_get(configuration: &configuration::Configuration, issue_id: &str, repo_slug: &str, workspace: &str) -> Result<models::Error, Error<RepositoriesWorkspaceRepoSlugIssuesIssueIdWatchGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_issue_id = issue_id;
    let p_path_repo_slug = repo_slug;
    let p_path_workspace = workspace;

    let uri_str = format!("{}/repositories/{workspace}/{repo_slug}/issues/{issue_id}/watch", configuration.base_path, issue_id=crate::apis::urlencode(p_path_issue_id), repo_slug=crate::apis::urlencode(p_path_repo_slug), workspace=crate::apis::urlencode(p_path_workspace));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_path_to_error::deserialize(&mut serde_json::Deserializer::from_str(&content)).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Error`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Error`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<RepositoriesWorkspaceRepoSlugIssuesIssueIdWatchGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Start watching this issue.  To start watching this issue, do an empty PUT. The 204 status code indicates that the operation was successful.
pub async fn repositories_workspace_repo_slug_issues_issue_id_watch_put(configuration: &configuration::Configuration, issue_id: &str, repo_slug: &str, workspace: &str) -> Result<models::Error, Error<RepositoriesWorkspaceRepoSlugIssuesIssueIdWatchPutError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_issue_id = issue_id;
    let p_path_repo_slug = repo_slug;
    let p_path_workspace = workspace;

    let uri_str = format!("{}/repositories/{workspace}/{repo_slug}/issues/{issue_id}/watch", configuration.base_path, issue_id=crate::apis::urlencode(p_path_issue_id), repo_slug=crate::apis::urlencode(p_path_repo_slug), workspace=crate::apis::urlencode(p_path_workspace));
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_path_to_error::deserialize(&mut serde_json::Deserializer::from_str(&content)).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Error`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Error`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<RepositoriesWorkspaceRepoSlugIssuesIssueIdWatchPutError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Creates a new issue.  This call requires authentication. Private repositories or private issue trackers require the caller to authenticate with an account that has appropriate authorization.  The authenticated user is used for the issue's `reporter` field.
pub async fn repositories_workspace_repo_slug_issues_post(configuration: &configuration::Configuration, repo_slug: &str, workspace: &str, _body: models::Issue) -> Result<models::Issue, Error<RepositoriesWorkspaceRepoSlugIssuesPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_repo_slug = repo_slug;
    let p_path_workspace = workspace;
    let p_body__body = _body;

    let uri_str = format!("{}/repositories/{workspace}/{repo_slug}/issues", configuration.base_path, repo_slug=crate::apis::urlencode(p_path_repo_slug), workspace=crate::apis::urlencode(p_path_workspace));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };
    req_builder = req_builder.json(&p_body__body);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_path_to_error::deserialize(&mut serde_json::Deserializer::from_str(&content)).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Issue`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Issue`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<RepositoriesWorkspaceRepoSlugIssuesPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Returns the milestones that have been defined in the issue tracker.  This resource is only available on repositories that have the issue tracker enabled.
pub async fn repositories_workspace_repo_slug_milestones_get(configuration: &configuration::Configuration, repo_slug: &str, workspace: &str) -> Result<models::PaginatedMilestones, Error<RepositoriesWorkspaceRepoSlugMilestonesGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_repo_slug = repo_slug;
    let p_path_workspace = workspace;

    let uri_str = format!("{}/repositories/{workspace}/{repo_slug}/milestones", configuration.base_path, repo_slug=crate::apis::urlencode(p_path_repo_slug), workspace=crate::apis::urlencode(p_path_workspace));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_path_to_error::deserialize(&mut serde_json::Deserializer::from_str(&content)).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PaginatedMilestones`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PaginatedMilestones`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<RepositoriesWorkspaceRepoSlugMilestonesGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Returns the specified issue tracker milestone object.
pub async fn repositories_workspace_repo_slug_milestones_milestone_id_get(configuration: &configuration::Configuration, milestone_id: i32, repo_slug: &str, workspace: &str) -> Result<models::Milestone, Error<RepositoriesWorkspaceRepoSlugMilestonesMilestoneIdGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_milestone_id = milestone_id;
    let p_path_repo_slug = repo_slug;
    let p_path_workspace = workspace;

    let uri_str = format!("{}/repositories/{workspace}/{repo_slug}/milestones/{milestone_id}", configuration.base_path, milestone_id=p_path_milestone_id, repo_slug=crate::apis::urlencode(p_path_repo_slug), workspace=crate::apis::urlencode(p_path_workspace));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_path_to_error::deserialize(&mut serde_json::Deserializer::from_str(&content)).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Milestone`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Milestone`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<RepositoriesWorkspaceRepoSlugMilestonesMilestoneIdGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Returns the versions that have been defined in the issue tracker.  This resource is only available on repositories that have the issue tracker enabled.
pub async fn repositories_workspace_repo_slug_versions_get(configuration: &configuration::Configuration, repo_slug: &str, workspace: &str) -> Result<models::PaginatedVersions, Error<RepositoriesWorkspaceRepoSlugVersionsGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_repo_slug = repo_slug;
    let p_path_workspace = workspace;

    let uri_str = format!("{}/repositories/{workspace}/{repo_slug}/versions", configuration.base_path, repo_slug=crate::apis::urlencode(p_path_repo_slug), workspace=crate::apis::urlencode(p_path_workspace));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_path_to_error::deserialize(&mut serde_json::Deserializer::from_str(&content)).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PaginatedVersions`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PaginatedVersions`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<RepositoriesWorkspaceRepoSlugVersionsGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Returns the specified issue tracker version object.
pub async fn repositories_workspace_repo_slug_versions_version_id_get(configuration: &configuration::Configuration, repo_slug: &str, version_id: i32, workspace: &str) -> Result<models::Version, Error<RepositoriesWorkspaceRepoSlugVersionsVersionIdGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_repo_slug = repo_slug;
    let p_path_version_id = version_id;
    let p_path_workspace = workspace;

    let uri_str = format!("{}/repositories/{workspace}/{repo_slug}/versions/{version_id}", configuration.base_path, repo_slug=crate::apis::urlencode(p_path_repo_slug), version_id=p_path_version_id, workspace=crate::apis::urlencode(p_path_workspace));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_path_to_error::deserialize(&mut serde_json::Deserializer::from_str(&content)).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Version`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Version`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<RepositoriesWorkspaceRepoSlugVersionsVersionIdGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

